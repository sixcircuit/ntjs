"use strict";

var { _, eq, ok, async } = require('./common.js');

test("a test of fulfill values", function(done){

   for(var i = 0; i < 20; i++){
      var x = 3 * Math.random();
      await{ async.echo(defer(var y, z), x, 2); }
      eq(x, y);
      eq(z, 2);
   }

   done();
});

/*
test("assign to array index", function(done){

   var a = [];

   await{ async.echo(defer(a[0], a[1], a[2]), 0, 1, 2); }

   eq(a, [0, 1, 2]);

   done();
});

test("assign to object key", function(done){

   var o = {};

   await{ async.echo(defer(o.zero, o.one, o.two), 0, 1, 2); }

   eq(o, { zero: 0, one: 1, two: 2 });

   done();
});

*/

/*
test("test capture of defer slots", function(done){

   var slots = {};
   var n = 10;

   var slots = [], x = {}, jams = []; 

   var hard = { foo : { bar: [ { baz : [] } ] } };

   function helper(i, cb){
      await{ setTimeout(defer(), i); }
      return cb(i, 7*i, 2*i, 3*i);
   }

   for (var i = 0; i < n; i++) {
      x[i] = i;
   }

   var dummy = { puppy : 0 };

   await {
      for (var i = 0; i < n; i++) {
         helper(i, defer(
            slots[x[i]],
            dummy.puppy, jams[i], 
            hard.foo["bar"][0].baz[i]
         ));
      }
   }

   for (var i = 0; i < n; i++){
      _.p("i.0: ", i);
      eq(slots[i], i);
      _.p("i.1: ", i);
      eq(jams[i], i*2);
      _.p("i.2: ", i);
      eq(hard.foo.bar[0].baz[i], i*3);
      _.p("i.3: ", i);
    }

    done();
});
*/

const n = 10;
const expected_x = _.map(_.range(n), function(v){ return(v); });
const expected_y = _.map(_.range(n), function(v){ return(v*2); });
const expected_raw = _.map(_.range(n), function(v){ return([v, v*2]); });

test("array notation serial", function(done){

   var x = [];

   // works because control structures get suspended in whole async function
   for(var i = 0; i < n; i++){
      await { 
         async.echo(defer(x[i]), i, i*2);
      }
   }

   eq(x, expected_x);

   done();
});

test("array notation serial each", function(done){

   var x = [];

   // does works but there is no way to get the results
   // this is just a poorly structured parallel pattern
   // you can achieve the same thing wrapping the whole each and using array notation
   _.each(_.range(n), function(i){
      await { 
         async.echo(defer(x[i]), i, i*2);
      }
   });

   setTimeout(function(){
      eq(x, expected_x);
      done();
   }, ((n+1) * 10));
});

test("array notation serial complex lhs", function(done){

   var hard = { foo : { bar: [ { baz : [] } ] } };

   for(var i = 0; i < n; i++){
      await { 
         async.echo(defer(hard.foo["bar"][0].baz[i]), i, i*2);
      }
   }

   eq(hard.foo["bar"][0].baz, expected_x);

   done();

});

test("array notation serial each async", function(done){

   let foo = { x: [] };
   let y = [];
   let ignore = [];

   await{
      _.each.async(_.range(n), function(i, v, next){
         await { async.echo(defer(foo.x[i], ignore), i, i*2); }
         await { async.echo(defer(ignore, y[i]), i, i*2); }
         next();
      }, defer());
   }

   eq(foo.x, expected_x);
   eq(y, expected_y);

   done();

});

/*

test("array notation parallel", function(done){
    
   var x = [];

   await { 
      for(var i = 0; i < n; i++){
         async.echo(defer(let x[], y[]), i, i*2);
      }
   }

   eq(x, expected_x);
   eq(y, expected_y);

   done();

});

test("array notation parallel each", function(done){
    
   var x = [];

   await { 
      _.each(_.range(n), function(i){
         async.echo(defer(let x[], y[]), i, i*2);
      });
   }

   eq(x, expected_x);
   eq(y, expected_y);

   done();

});



test("array notation parallel raw", function(done){
    
   await { 
      for(var i = 0; i < n; i++){
         async.echo(defer(let raw x[]), i, i*2);
      }
   }

   eq(x, expected_raw);

   done();

});

*/
