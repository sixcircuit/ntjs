"use strict";

var { _, eq, ok, async } = require('./common.js');

test("var x, y", function(done){

   await{ async.echo(defer(var x, y), 1, 2); }
   eq(x, 1); eq(y, 2);
   done();
});

test("let x, y", function(done){

   await{ async.echo(defer(let x, y), 1, 2); }
   eq(x, 1); eq(y, 2);
   done();
});

test("const x, y", function(done){

   await{ async.echo(defer(const x, y), 1, 2); }
   eq(x, 1); eq(y, 2);
   done();
});

test("assign to var x, y", function(done){
   var x, y;
   await{ async.echo(defer(x, y), 1, 2); }
   eq(x, 1); eq(y, 2);
   done();
});

test("assign to let x, y", function(done){
   let x, y;
   await{ async.echo(defer(x, y), 1, 2); }
   eq(x, 1); eq(y, 2);
   done();
});


/* this blows up, like it's supposed to
test("assign to const x, y", function(done){
   const x, y;
   await{ async.echo(defer(x, y), 1, 2); }
   eq(x, 1); eq(y, 2);
   done();
});
*/

test("assign in a for loop", function(done){

   for(var i = 0; i < 20; i++){
      var x = Math.random();
      await{ async.echo(defer(var xx, two), x, 2); }
      eq(xx, x);
      eq(two, 2);
   }

   done();
});

test("assign to array index", function(done){

   var a = [];

   await{ async.echo(defer(a[0], a[1], a[2]), 0, 1, 2); }

   eq(a, [0, 1, 2]);

   done();
});

test("assign to object key", function(done){

   var o = {};

   await{ async.echo(defer(o.zero, o.one, o.two), 0, 1, 2); }

   eq(o, { zero: 0, one: 1, two: 2 });

   done();
});

const n = 10;
const expected_x = _.map(_.range(n), function(v){ return(v); });
const expected_y = _.map(_.range(n), function(v){ return(v*2); });
const expected_raw = _.map(_.range(n), function(v){ return([v, v*2]); });

test("array notation serial", function(done){

   var x = [];

   // works because control structures get suspended in whole async function
   for(var i = 0; i < n; i++){
      await { 
         async.echo(defer(x[i]), i, i*2);
      }
   }

   eq(x, expected_x);

   done();
});

test("array notation serial each", function(done){

   var x = [];

   // works but there is no way to get the results
   // this is just a poorly structured parallel pattern
   // you can achieve the same thing wrapping the whole each and using array notation
   _.each(_.range(n), function(i){
      await { 
         async.echo(defer(x[i]), i, i*2);
      }
   });

   setTimeout(function(){
      eq(x, expected_x);
      done();
   }, ((n+1) * 10));
});

test("array notation serial complex lhs", function(done){

   var hard = { foo : { bar: [ { baz : [] } ] } };

   for(var i = 0; i < n; i++){
      await { 
         async.echo(defer(hard.foo["bar"][0].baz[i]), i, i*2);
      }
   }

   eq(hard.foo["bar"][0].baz, expected_x);

   done();

});

test("array notation serial each async", function(done){

   let foo = { x: [] };
   let y = [];
   let ignore = [];

   await{
      _.each.async(_.range(n), function(i, v, next){
         await { async.echo(defer(foo.x[i], ignore), i, i*2); }
         await { async.echo(defer(ignore, y[i]), i, i*2); }
         next();
      }, defer());
   }

   eq(foo.x, expected_x);
   eq(y, expected_y);

   done();
});

test("array notation serial parallel each async", function(done){

   let foo = { x: [] };
   let y = [];
   let ignore = [];

   await{
      _.each.async(_.range(n), function(i, v, next){
         await { 
            async.echo(defer(foo.x[i], ignore), i, i*2);
            async.echo(defer(ignore, y[i]), i, i*2); 
         }
         next();
      }, defer());
   }

   eq(foo.x, expected_x);
   eq(y, expected_y);

   done();
});


test("array notation parallel", function(done){
    
   await { 
      for(var i = 0; i < n; i++){
         async.echo(defer(let x[], y[]), i, i*2);
      }
   }

   eq(x, expected_x);
   eq(y, expected_y);

   done();

});

test("array notation parallel each", function(done){
    
   throw new Error("need to finish parallel array notation");
});

/*
test("array notation parallel each", function(done){

   var x = [];

   await { 
      _.each(_.range(n), function(i){
         async.echo(defer(let x[], y[]), i, i*2);
      });
   }

   eq(x, expected_x);
   eq(y, expected_y);

   done();

});



test("array notation parallel raw", function(done){
    
   await { 
      for(var i = 0; i < n; i++){
         async.echo(defer(let raw x[]), i, i*2);
      }
   }

   eq(x, expected_raw);

   done();

});

test("array notation multiple parallel each", function(done){
    
   await { 
      _.each(_.range(n), function(i){
         (function(cb){
            var t = _.timestamp();
            await{
               async.echo(10, defer(let x, y), i, i*2);
               async.echo(20, defer(let xx, yy), i*3, i*4);
            }
            t = _.timestamp() - t;
            ok(t >= 20 && t < 25); // ran in parallel
            cb(x, y, xx, yy);
         })(defer(let x[], y[], xx[], yy[]))
      });
   }

   eq(x, expected_x);
   eq(y, expected_y);
   eq(xx, _.map(_.range(n), function(n){ return(n*3); });
   eq(yy, _.map(_.range(n), function(n){ return(n*4); });

   done();

});


test("array notation multiple parallel each", function(done){
    
   await { 
      _.each(_.range(n), function(i){
         async.echo(defer(let x[], y[]), i, i*2);
         async.echo(defer(let xx[], yy[]), i, i*2);
      });
   }

   eq(x, expected_x);
   eq(y, expected_y);

   eq(xx, expected_x);
   eq(yy, expected_y);


   done();

});

*/
